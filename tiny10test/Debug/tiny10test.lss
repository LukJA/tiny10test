
AVRASM ver. 2.2.6  C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm Mon Mar 20 21:46:53 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.1.102\avrasm\inc\tn10def.inc'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(67): warning: Register r28 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(69): warning: Register r31 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(70): warning: Register r30 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(72): warning: Register r29 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(230): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\i2clib.asm'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(232): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\uartlib.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.1.102\avrasm\inc\tn10def.inc'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(230): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\i2clib.asm'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(232): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\uartlib.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny10.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn10def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny10
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny10
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN10DEF_INC_
                                 #define _TN10DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny10
                                 #pragma AVRPART ADMIN PART_NAME ATtiny10
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x03
                                 
                                 #pragma AVRPART CORE CORE_VERSION AVR8L_0
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	CCP	= 0x3c
                                 .equ	RSTFLR	= 0x3b
                                 .equ	SMCR	= 0x3a
                                 .equ	OSCCAL	= 0x39
                                 .equ	CLKMSR	= 0x37
                                 .equ	CLKPSR	= 0x36
                                 .equ	PRR	= 0x35
                                 .equ	VLMCSR	= 0x34
                                 .equ	NVMCMD	= 0x33
                                 .equ	NVMCSR	= 0x32
                                 .equ	WDTCSR	= 0x31
                                 .equ	GTCCR	= 0x2f
                                 .equ	TCCR0A	= 0x2e
                                 .equ	TCCR0B	= 0x2d
                                 .equ	TCCR0C	= 0x2c
                                 .equ	TIMSK0	= 0x2b
                                 .equ	TIFR0	= 0x2a
                                 .equ	TCNT0L	= 0x28
                                 .equ	TCNT0H	= 0x29
                                 .equ	OCR0AL	= 0x26
                                 .equ	OCR0AH	= 0x27
                                 .equ	OCR0BL	= 0x24
                                 .equ	OCR0BH	= 0x25
                                 .equ	ICR0L	= 0x22
                                 .equ	ICR0H	= 0x23
                                 .equ	ACSR	= 0x1f
                                 .equ	ADCSRA	= 0x1d
                                 .equ	ADCSRB	= 0x1c
                                 .equ	ADMUX	= 0x1b
                                 .equ	ADCL	= 0x19
                                 .equ	DIDR0	= 0x17
                                 .equ	EICRA	= 0x15
                                 .equ	EIFR	= 0x14
                                 .equ	EIMSK	= 0x13
                                 .equ	PCICR	= 0x12
                                 .equ	PCIFR	= 0x11
                                 .equ	PCMSK	= 0x10
                                 .equ	PORTCR	= 0x0c
                                 .equ	PUEB	= 0x03
                                 .equ	PORTB	= 0x02
                                 .equ	DDRB	= 0x01
                                 .equ	PINB	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel Selection Bits
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 
                                 ; ADCL - ADC Data Register
                                 .equ	ADC0	= 0	; ADC Data Register Bit 0
                                 .equ	ADC1	= 1	; ADC Data Register Bit 1
                                 .equ	ADC2	= 2	; ADC Data Register Bit 2
                                 .equ	ADC3	= 3	; ADC Data Register Bit 3
                                 .equ	ADC4	= 4	; ADC Data Register Bit 4
                                 .equ	ADC5	= 5	; ADC Data Register Bit 5
                                 .equ	ADC6	= 6	; ADC Data Register Bit 6
                                 .equ	ADC7	= 7	; ADC Data Register Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture  Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; CCP - Configuration Change Protection
                                 .equ	CCP0	= 0	; Configuration Change Protection bit 0
                                 .equ	CCP1	= 1	; Configuration Change Protection bit 1
                                 .equ	CCP2	= 2	; Configuration Change Protection bit 2
                                 .equ	CCP3	= 3	; Configuration Change Protection bit 3
                                 .equ	CCP4	= 4	; Configuration Change Protection bit 4
                                 .equ	CCP5	= 5	; Configuration Change Protection bit 5
                                 .equ	CCP6	= 6	; Configuration Change Protection bit 6
                                 .equ	CCP7	= 7	; Configuration Change Protection bit 7
                                 
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; CLKMSR - Clock Main Settings Register
                                 .equ	CLKMS0	= 0	; Clock Main Select Bit 0
                                 .equ	CLKMS1	= 1	; Clock Main Select Bit 1
                                 
                                 ; CLKPSR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRTIM0	= 0	; Power Reduction Timer/Counter0
                                 .equ	PRADC	= 1	; Power Reduction ADC
                                 
                                 ; VLMCSR - Vcc Level Monitoring Control and Status Register
                                 .equ	VLM0	= 0	; Trigger Level of Voltage Level Monitor bit 0
                                 .equ	VLM1	= 1	; Trigger Level of Voltage Level Monitor bit 1
                                 .equ	VLM2	= 2	; Trigger Level of Voltage Level Monitor bit 2
                                 .equ	VLMIE	= 6	; VLM Interrupt Enable
                                 .equ	VLMF	= 7	; VLM Flag
                                 
                                 ; RSTFLR - Reset Flag Register
                                 .equ	PORF	= 0	; Power-on Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; NVMCSR - Non-Volatile Memory Control and Status Register
                                 .equ	NVMBSY	= 7	; Non-Volatile Memory Busy
                                 
                                 ; NVMCMD - Non-Volatile Memory Command
                                 .equ	NVMCMD0	= 0	; 
                                 .equ	NVMCMD1	= 1	; 
                                 .equ	NVMCMD2	= 2	; 
                                 .equ	NVMCMD3	= 3	; 
                                 .equ	NVMCMD4	= 4	; 
                                 .equ	NVMCMD5	= 5	; 
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTCR - Port Control Register
                                 .equ	BBMB	= 1	; Break-Before-Make Mode Enable
                                 
                                 ; PUEB - Pull-up Enable Control Register
                                 .equ	PUEB0	= 0	; 
                                 .equ	PUEB1	= 1	; 
                                 .equ	PUEB2	= 2	; 
                                 .equ	PUEB3	= 3	; 
                                 
                                 ; PORTB - Input Pins, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 
                                 ; PINB - Port B Data register
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 
                                 ; EIFR - External Interrupt Flag register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Mask Register
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0A - Timer/Counter 0 Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode for Channel B bit 0
                                 .equ	COM0B1	= 5	; Compare Output Mode for Channel B bit 1
                                 .equ	COM0A0	= 6	; Compare Output Mode for Channel A bit 0
                                 .equ	COM0A1	= 7	; Compare Output Mode for Channel A bit 1
                                 
                                 ; TCCR0B - Timer/Counter 0 Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; Waveform Generation Mode
                                 .equ	WGM03	= 4	; Waveform Generation Mode
                                 .equ	ICES0	= 6	; Input Capture Edge Select
                                 .equ	ICNC0	= 7	; Input Capture Noise Canceler
                                 
                                 ; TCCR0C - Timer/Counter 0 Control Register C
                                 .equ	FOC0B	= 6	; Force Output Compare for Channel B
                                 .equ	FOC0A	= 7	; Force Output Compare for Channel A
                                 
                                 ; TIMSK0 - Timer Interrupt Mask Register 0
                                 .equ	TOIE0	= 0	; Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Output Compare A Match Interrupt Enable
                                 .equ	OCIE0B	= 2	; Output Compare B Match Interrupt Enable
                                 .equ	ICIE0	= 5	; Input Capture Interrupt Enable
                                 
                                 ; TIFR0 - Overflow Interrupt Enable
                                 .equ	TOV0	= 0	; Timer Overflow Flag
                                 .equ	OCF0A	= 1	; Timer Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer Output Compare Flag 0B
                                 .equ	ICF0	= 5	; Input Capture Flag
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSR	= 0	; Prescaler Reset
                                 .equ	TSM	= 7	; Timer Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control and Status Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timer Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timer Interrupt Flag
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; BYTE0 fuse bits
                                 .equ	RSTDISBL	= 0	; Disable external reset
                                 .equ	WDTON	= 1	; Watch dog timer always on
                                 .equ	CKOUT	= 2	; Output external clock
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0040
                                 .equ	SRAM_SIZE	= 32
                                 .equ	RAMEND	= 0x005f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x0000
                                 .equ	EEPROMEND	= 0x0000
                                 
                                 ; ***** MEMORY MAPPED NVM ************************************************
                                 .equ	MAPPED_FLASH_START	= 0x4000
                                 .equ	MAPPED_LOCKBITS_0	= 0x3f00
                                 .equ	MAPPED_CONFIG_0	= 0x3f40
                                 .equ	MAPPED_CALIB_0	= 0x3f80
                                 .equ	MAPPED_SIGN_0	= 0x3fc0
                                 .equ	MAPPED_SIGN_1	= 0x3fc1
                                 .equ	MAPPED_SIGN_2	= 0x3fc2
                                 .equ	MAPPED_FLASH_SIZE	= 0x0400
                                 .equ	MAPPED_FLASH_END	= 0x43ff
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 0
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 32
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x40
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
                                 .equ	ICP0addr	= 0x0003	; Timer/Counter0 Input Capture
                                 .equ	OVF0addr	= 0x0004	; Timer/Counter0 Overflow
                                 .equ	OC0Aaddr	= 0x0005	; Timer/Counter Compare Match A
                                 .equ	OC0Baddr	= 0x0006	; Timer/Counter Compare Match B
                                 .equ	ACIaddr	= 0x0007	; Analog Comparator
                                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                                 .equ	VLMaddr	= 0x0009	; Vcc Voltage Level Monitor
                                 .equ	ADCCaddr	= 0x000a	; ADC Conversion Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 11	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _TN10DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; tiny10test.asm
                                 ;
                                 ; Created: 22/11/2016 21:30:59
                                 ; Author : lukej
                                 ;
                                 
                                 //--------------------------------------------- defines 
                                 
                                 .equ SDA = PB2 // define pins
                                 .equ SCL = PB0
                                 
                                 // LIS register addresses
                                 .equ LIS_W = 0B00110000 // lis addr + write
                                 .equ LIS_R = 0B00110001 // lis addr + read
                                 
                                 .equ CTRL_REG1 = 0x20
                                 .equ CTRL_REG2 = 0x21
                                 .equ CTRL_REG3 = 0x22
                                 .equ CTRL_REG4 = 0x23
                                 .equ CTRL_REG5 = 0x24
                                 .equ CTRL_REG6 = 0x25
                                 
                                 .equ INT1_CFG  = 0x30
                                 .equ INT1_SRC  = 0x31
                                 .equ INT1_THS  = 0x32
                                 .equ INT1_DURATION = 0x33
                                 
                                 // EEPROM address registers
                                 .equ EEP_W = 0B10100000 // eeprom addr + write
                                 .equ EEP_R = 0B10100001 // eeprom addr + read
                                 
                                 // PCF address registers
                                 .equ PCF_W = 0B10100010 // pcf + write
                                 .equ PCF_R = 0B10100011 // pcf + read
                                 
                                 .equ CTRL_STAT_1 = 0x00
                                 .equ CTRL_STAT_2 = 0x01
                                 .equ VL_seconds	= 0x02
                                 .equ Minutes	= 0x03
                                 .equ Hours		= 0x04
                                 .equ Days		= 0x05
                                 .equ Weekdays	= 0x06
                                 .equ Century_months	= 0x07
                                 .equ Years		= 0x08
                                 .equ CLKOUT_control	= 0x0D
                                 .equ Timer_control	= 0x0E
                                 .equ Timer		= 0x0F
                                 
                                 // internal 
                                 .def GPR = r16 // General purpose Reg (local) (assume nothing)
                                 .def GPRB = r23 // General purpose Reg B (local) (assume nothing)
                                 .def LOP = r17 // Register for loops
                                 
                                 .def RBitr = r18 // bit read reg
                                 .def RBytr = r19 // byte read reg
                                 
                                 .def WOT = r20 // write flow reg
                                 .def SAD = r21 // Sub address storage
                                 .def DAT = r22 // data storage
                                 
                                 .def DEL = r24 // delay reg
                                 .def DELH = r25 // delay higher reg
                                 
                                 // 26,27 used for pointing to sram
                                 
                                 .def WPS = r28 // watchdog prescaler
                                 
                                 .def EEH = r31  // we will be using the Z reg for addressing the EEprom
                                 .def EEL = r30  // Low bit too
                                 
                                 .def EEC = r29	// current address holder
                                 
                                 //--------------------------------------------
                                 
000000 c008                      rjmp skip				// making room for the interupt vector tables
                                 
                                 .org PCI0addr			// INT0addr is the address of EXT_INT0
000002 c02d                      rjmp PCI0_vect			// so run the handler
                                 .org WDTaddr			// WDTaddr is the address of the WDT timeout
000008 c030                      rjmp WDT_vect			// so run the handler
                                 
                                 skip:
                                 
                                 // CODE TO RUN: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                 
                                 // Setup the LIS3DH --
                                 
                                 // enable all axes, normal mode 100Hz rate
000009 e250                      ldi SAD, CTRL_REG1
00000a ea67                      ldi DAT, 0xA7
00000b d0ef                      rcall LIS_CMD
                                 
                                 // disable the HP filter
                                 //ldi SAD, CTRL_REG2
                                 //ldi DAT, 0x00
                                 //rcall LIS_CMD
                                 
                                 // Int driven to INT1 pin
00000c e252                      ldi SAD, CTRL_REG3
00000d e460                      ldi DAT, 0x40
00000e d0ec                      rcall LIS_CMD
                                 
                                 // Full Scale = 16G
00000f e253                      ldi SAD, CTRL_REG4
000010 e360                      ldi DAT, 0x30
000011 d0e9                      rcall LIS_CMD
                                 
                                 // Interupt latched 
                                 // commenting out will remove latching effect
                                 //ldi SAD, CTRL_REG5
                                 //ldi DAT, 0x08
                                 //rcall LIS_CMD
                                 
                                 // threshold absolute 
000012 e352                      ldi SAD, INT1_THS
000013 e76f                      ldi DAT, 0x7F
000014 d0e6                      rcall LIS_CMD
                                 
                                 // Set minimum duration to x <- this is effectively sensitivity
000015 e353                      ldi SAD, INT1_DURATION
000016 e069                      ldi DAT, 0x09
000017 d0e3                      rcall LIS_CMD
                                 
                                 // interrupt generation on all axis
000018 e350                      ldi SAD, INT1_CFG
000019 e06a                      ldi DAT, 0x0A
00001a d0e0                      rcall LIS_CMD
                                 
                                 // ---------------
                                 
                                 //  load the next available eeprom address into its pointer
                                 //  stored in 0 and 1 of the eeprom itself
                                 
00001b e0f0                      ldi EEH, 0x00		// set location 0
00001c e0e0                      ldi EEL, 0x00		// set location 0
                                 
00001d d0eb                      rcall EEP_READ_BYTE	// load the low byte
                                 
00001e 2fd3                      mov EEC, RBytr		// set the new write addr
00001f e0d0                      ldi EEC, 0x00
                                 
000020 95d3                      inc EEC		// increment location
                                 
                                 // ---------------
                                 
                                 // set up all interupts
000021 94f8                      cli
                                 
                                 // enable wdt to blink slowly   
000022 e0c6                      ldi WPS, 0B0110		// highest timeout 
000023 2700                      clr GPR
000024 bf01                      out WDTCSR, GPR			// clean up
000025 d124                      rcall load_prescaler
                                 
                                 // enable pin change int on SCL for button, PB1 for LIS
                                 
000026 2700                      clr GPR
000027 e003                      ldi GPR, 0B0011
000028 bb00                      out PCMSK, GPR
000029 e001                      ldi GPR, 0B0001
00002a bb02                      out PCICR, GPR
                                 
00002b 9478                      sei
                                 
                                 // ----------------------
                                 
                                 start:				// main loop
                                 
00002c e005                      ldi GPR, 0B0101		// Sleep code
00002d bf0a                      out SMCR, GPR		// set sleep mode to power down + enable
00002e 9588                      sleep
                                 
00002f cffc                      rjmp start
                                 
                                 // ----------------------
                                 
                                 // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                 
                                 
                                 
                                 
                                 // Interrupt vectors
                                 
                                 // LIS threshhold exceeded interupt OR button pressed interupt
                                 PCI0_vect:
                                 
000030 94f8                      	cli
                                 	
000031 d030                      	rcall read_SCL	// read the pin to check if it was the button
                                 
000032 ff20                      	sbrs RBitr, SCL	// if it was run button
000033 d158                      	rcall button_event // button
                                 
000034 d033                      	rcall read_PB1 // read to see if it was the accelerometer
                                 
000035 ff21                      	sbrs RBitr, PB1 // if it was run accel
000036 d12b                      	rcall accel_event
                                 
000037 9478                      	sei
                                 
000038 9518                      	reti // esc
                                 
                                 // Periodic watchdog interupt
                                 WDT_vect:
                                 
000039 94f8                      	cli
                                 
00003a d00b                      	rcall low_SDA // pulse led 
                                 
00003b b701                      	in GPR, WDTCSR		// clear the watchdog
00003c 6400                      	ori GPR, (1<<WDIE)
00003d 6008                      	ori GPR, (1<<WDE)
00003e bf01                      	out WDTCSR, GPR
                                 
00003f ef8f                      	ldi DEL, 255 // delay		
000040 d086                      	rcall delay
                                 
000041 ef8f                      	ldi DEL, 255 // delay			 
000042 d084                      	rcall delay
                                 
000043 d009                      	rcall high_SDA // pulse led
                                 	
000044 9478                      	sei
                                 
000045 9518                      	reti
                                 
                                 
                                 // include i2c external library
                                 #include "i2clib.asm"
                                 
                                 
                                 // I2C Low Level
                                 
                                 /* Pull the SDA line low */
                                 low_SDA:				// SDA -> GND
                                 
000046 b101                      	in  GPR, DDRB		// read DDR 
000047 6004                      	ori  GPR, (1<<SDA)  // add SDA set bit
000048 b901                      	out DDRB, GPR		// set sda output
                                 
000049 b102                      	in  GPR, PORTB		// read portb 
00004a 7f0b                      	andi GPR, ~(1<<SDA) // mask SDA bit
00004b b902                      	out PORTB, GPR		// set output low
                                 
00004c 9508                      	ret
                                 	
                                 /* Allow the SDA line to tristate (ext Pull-Up) */
                                 high_SDA:				// SDA -> tristate
                                 
00004d b101                      	in  GPR, DDRB		// read DDR 
00004e 7f0b                      	andi GPR, ~(1<<SDA) // mask SDA bit
00004f b901                      	out DDRB, GPR		// set sda input
                                 
000050 9508                      	ret
                                 	
                                 /* Pull the SCL line low */
                                 low_SCL:				// SCL -> GND
                                 
000051 b101                      	in  GPR, DDRB		// read DDR 
000052 6001                      	ori  GPR, (1<<SCL)  // add SCL set bit
000053 b901                      	out DDRB, GPR		// set scl output
                                 
000054 b102                      	in  GPR, PORTB		// read portb 
000055 7f0e                      	andi GPR, ~(1<<SCL) // mask SCL bit
000056 b902                      	out PORTB, GPR		// set output low
                                 
000057 9508                      	ret
                                 	
                                 /* Allow the SDA line to tristate (ext Pull-Up) */
                                 high_SCL:				// SCL -> tristate
                                 
000058 b101                      	in  GPR, DDRB		// read DDR 
000059 7f0e                      	andi GPR, ~(1<<SCL) // mask SCL bit
00005a b901                      	out DDRB, GPR		// set scl input
                                 
00005b 9508                      	ret
                                 
                                 /* read the current level of SDA into the RBitr reg masking to SDA only */
                                 read_SDA:
                                 	
00005c b101                      	in  GPR, DDRB		// read DDR 
00005d 7f0b                      	andi GPR, ~(1<<SDA) // mask SDA bit
00005e b901                      	out DDRB, GPR		// set sda input
                                 
00005f b120                      	in  RBitr, PINB		// read pinB into RBitr
000060 7024                      	andi RBitr, (1<<SDA)// mask to SDA
                                 
000061 9508                      	ret
                                 	
                                 /* read the current level of SCL into the RBitr reg masking to SCL only */
                                 read_SCL:
                                 	
000062 b101                      	in  GPR, DDRB		// read DDR 
000063 7f0e                      	andi GPR, ~(1<<SCL) // mask SCL bit
000064 b901                      	out DDRB, GPR		// set scl input
                                 
000065 b120                      	in  RBitr, PINB		// read pinB into RBitr
000066 7021                      	andi RBitr, (1<<SCL)// mask to SDA
                                 
000067 9508                      	ret
                                 
                                 /* read the current level of PB1 into the RBitr reg masking to PB1 only */
                                 read_PB1:
                                 	
000068 b101                      	in  GPR, DDRB		// read DDR 
000069 7f0d                      	andi GPR, ~(1<<PB1) // mask SCL bit
00006a b901                      	out DDRB, GPR		// set scl input
                                 
00006b b120                      	in  RBitr, PINB		// read pinB into RBitr
00006c 7022                      	andi RBitr, (1<<PB1)// mask to SDA
                                 
00006d 9508                      	ret
                                 
                                 	/* Pull the SDA line low */
                                 low_PB1:				// SDA -> GND
                                 
00006e b101                      	in  GPR, DDRB		// read DDR 
00006f 6002                      	ori  GPR, (1<<PB1)  // add SDA set bit
000070 b901                      	out DDRB, GPR		// set sda output
                                 
000071 b102                      	in  GPR, PORTB		// read portb 
000072 7f0d                      	andi GPR, ~(1<<PB1) // mask SDA bit
000073 b902                      	out PORTB, GPR		// set output low
                                 
000074 9508                      	ret
                                 	
                                 /* Allow the SDA line to tristate (ext Pull-Up) */
                                 high_PB1:				// SDA -> tristate
                                 
000075 b101                      	in  GPR, DDRB		// read DDR 
000076 7f0d                      	andi GPR, ~(1<<PB1) // mask SDA bit
000077 b901                      	out DDRB, GPR		// set sda input
                                 
000078 9508                      	ret
                                 
                                 
                                 // I2C High Level
                                 
                                 /* Perform a start condition or restart condition, performs both */
                                 start_condition:
                                 
000079 dfd3                      	rcall high_SDA		// SDA high <- allows for restart to use same call
00007a dfdd                      	rcall high_SCL		// SCL high 
                                 	
00007b 0000                      	nop					// take a real quick break (no op)
                                 	
00007c dfc9                      	rcall low_SDA		// SDA low BEFORE
00007d 0000                      	nop					// break
00007e dfd2                      	rcall low_SCL		// SCL low NEXT
00007f 0000                      	nop					// break
                                 	
000080 9508                      	ret
                                 
                                 /* perform a stop condition */
                                 stop_condition:
                                 
000081 dfc4                      	rcall low_SDA		// just make sure
000082 0000                      	nop					// break
000083 dfd4                      	rcall high_SCL		// SCL high BEFORE
000084 0000                      	nop					// break
000085 dfc7                      	rcall high_SDA		// SDA high NEXT
                                 
000086 9508                      	ret
                                 
                                 /* write the MSB of the WOT to the SDA pin and pulse the clock */
                                 write_bit:	
                                 
000087 fd47                      	sbrc WOT, 7			// skip the next line if WOT[7] = 0
000088 dfc4                      		rcall high_SDA
000089 ff47                      	sbrs WOT, 7			// skip the next line if WOT[7] = 1
00008a dfbb                      		rcall low_SDA
                                 			
00008b dfcc                      	rcall high_SCL		// pulse clock
00008c 0000                      	nop
00008d dfc3                      	rcall low_SCL
                                 
00008e 9508                      	ret
                                 	
                                 /* read the current level of SDA and insert it into RBitr[0]
                                    seperated from RBytr so that this can be used for ack/nack */
                                 read_bit:
                                 
00008f 0000                      	nop
000090 dfc7                      	rcall high_SCL		// clock up to lock data
000091 0000                      	nop
                                 
000092 dfc9                      	rcall read_SDA		// read SDA into RBitr
                                 
000093 2700                      	clr GPR			
000094 fd22                      	sbrc RBitr, SDA		// skip the next line if SDA bit in RBitr is cleared
000095 e001                      	ldi  GPR, 0x1		
000096 2f20                      	mov RBitr, GPR		// set the LSB of RBitr to be the value of SDA
                                 
000097 0000                      	nop
000098 dfb8                      	rcall low_SCL		// clock down to accept new data
                                 
000099 9508                      	ret
                                 
                                 /* write the contents of WOT the I2C line */
                                 write_byte:
                                 
00009a e018                      	ldi LOP, 8		// init loop reg
                                 
                                 	w_b_s:
00009b 951a                      	dec LOP			// loop--
                                 
00009c dfea                      	rcall write_bit // write the MSB to the bus
00009d 0f44                      	lsl WOT			// left shift to the next bit to send
                                 
00009e 3010                      	cpi LOP, 0		// check if its 0 yet
00009f f7d9                      	brne w_b_s		// if not go back to w_b_s
                                 
0000a0 dfac                      	rcall high_SDA	// release control of SDA
0000a1 9508                      	ret
                                 
                                 /* read a byte of data from the bus via read_bit, and store the result in RBytr */
                                 read_byte:
                                 
0000a2 e018                      	ldi LOP, 8		// init loop reg
                                 
0000a3 2777                      	clr GPRB		// clean GPRB for use (GPR is used in read_bit)
                                 
                                 	r_b_s:
0000a4 951a                      	dec LOP			// loop--
                                 
0000a5 dfe9                      	rcall read_bit	// read a bit into RBitr
0000a6 0f77                      	lsl GPRB		// shift the GP to the left to free the next spot
0000a7 2b72                      	or GPRB, RBitr	// move the read bit into said spot
                                 
0000a8 3010                      	cpi LOP, 0		// check if its 0 yet
0000a9 f7d1                      	brne r_b_s		// if not go back to r_b_s
                                 
0000aa 2f37                      	mov RBytr, GPRB // move the new read byte into its designated reg
0000ab 9508                      	ret
                                 
                                 // include uart external library
                                 #include "uartlib.asm"
                                 
                                    Use DAT
                                    Finely tuned to 19200 baud 
                                    8 data 1 stop
                                    lsb first */
                                 // Uart output a byte
                                 uart_byte:
                                 
0000ac 2f46                      	mov WOT, DAT			// value of DAT into WOT
0000ad e018                      	ldi LOP, 8				// init loop reg
                                 
0000ae dfbf                      	rcall low_PB1			// start condition is initially low
                                 
0000af e084                      	ldi DEL, 4				// tuning delay
0000b0 d016                      	rcall delay
0000b1 0000                      	nop						// tuning delay
0000b2 0000                      	nop
                                 
                                 	u_a_s:
0000b3 951a                      	dec LOP					// loop-- plays the data out over the bus one bit at a time
                                 
0000b4 fd40                      	sbrc WOT, 0				// skip the next line if WOT[0] = 0
0000b5 dfbf                      		rcall high_PB1
0000b6 ff40                      	sbrs WOT, 0				// skip the next line if WOT[0] = 1
0000b7 dfb6                      		rcall low_PB1
0000b8 9546                      	lsr WOT					// left shift to the next bit to send
                                 		
0000b9 e083                      	ldi DEL, 3				// tuning delay
0000ba d00c                      	rcall delay
                                 
0000bb 0000                      	nop						// tuning delay
0000bc 0000                      	nop
0000bd 0000                      	nop
                                 
0000be 3010                      	cpi LOP, 0				// check if its 0 yet
0000bf f799                      	brne u_a_s				// if not go back to u_a_s
                                 
0000c0 0000                      	nop						// tuning delay
0000c1 0000                      	nop
0000c2 0000                      	nop
0000c3 0000                      	nop
                                 
0000c4 dfb0                      	rcall high_PB1			// release control of SDA
0000c5 9508                      	ret
                                 
                                 // uart input a byte
                                 
                                 uart_recieve:
                                 
0000c6 9508                      
                                 
                                 // User routines
                                 
                                 /* just something to delay by twice the number in DEL */
                                 delay:
                                 	d_s:
0000c7 958a                      	dec DEL
0000c8 0000                      	nop
0000c9 0000                      	nop
0000ca 3080                      	cpi DEL, 0
0000cb f7d9                      	brne d_s
                                 
0000cc 9508                      	ret
                                 
                                 delayL:
                                 	dLH_s:
0000cd 959a                      	dec DELH
                                 	dL_s:
0000ce 958a                      	dec DEL
0000cf 0000                      	nop
0000d0 0000                      	nop
0000d1 0000                      	nop
0000d2 0000                      	nop
0000d3 0000                      	nop
0000d4 0000                      	nop
0000d5 0000                      	nop
0000d6 0000                      	nop
0000d7 0000                      	nop
0000d8 0000                      	nop
0000d9 0000                      	nop
0000da 0000                      	nop
0000db 0000                      	nop
0000dc 0000                      	nop
0000dd 0000                      	nop
0000de 0000                      	nop
0000df 0000                      	nop
0000e0 0000                      	nop
0000e1 0000                      	nop
0000e2 0000                      	nop
0000e3 3080                      	cpi DEL, 0
0000e4 f749                      	brne dL_s
0000e5 3090                      	cpi DELH, 0
0000e6 f731                      	brne dLH_s
                                 
0000e7 9508                      	ret
                                 
                                 /* Read command for LIS3DH 
                                    reads sub-address SAD into RBytr */
                                 LIS_READ:
                                 
0000e8 df90                      	rcall start_condition	// start con
                                 
0000e9 e340                      	ldi WOT, LIS_W			// lis addr + write slave identifier into WOT
0000ea dfaf                      	rcall write_byte		// Write the above to the bus
0000eb dfa3                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
0000ec e08a                      	ldi DEL, 10				// TAKE 5
0000ed dfd9                      	rcall delay
                                 
0000ee 2f45                      	mov WOT, SAD			// value of SAD (sub address in lis reg file) into WOT
0000ef dfaa                      	rcall write_byte		// Write the above to the bus
0000f0 df9e                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
0000f1 df87                      	rcall start_condition	// repeated start con
                                 
0000f2 e341                      	ldi WOT, LIS_R			// lis addr + read slave identifier into WOT
0000f3 dfa6                      	rcall write_byte		// Write the above to the bus
0000f4 df9a                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
0000f5 e085                      	ldi DEL, 5				// TAKE 5
0000f6 dfd0                      	rcall delay
                                  
0000f7 dfaa                      	rcall read_byte			// read a byte into RBytr for use 
0000f8 df96                      	rcall read_bit			// Master Not Acknowledge 
                                 
0000f9 df87                      	rcall stop_condition	// stop con
                                 
0000fa 9508                      	ret
                                 
                                 /* Write command for LIS3DH 
                                    writes DAT into sub-address SAD */
                                 LIS_CMD:	 
                                 
0000fb df7d                      	rcall start_condition	// start con
                                 
0000fc e340                      	ldi WOT, LIS_W			// lis addr + write slave identifier into WOT
0000fd df9c                      	rcall write_byte		// Write the above to the bus
0000fe df90                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
0000ff 2f45                      	mov WOT, SAD			// value of SAD (sub address in lis reg file) into WOT
000100 df99                      	rcall write_byte		// Write the above to the bus
000101 df8d                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000102 2f46                      	mov WOT, DAT			// value of DAT into WOT
000103 df96                      	rcall write_byte		// Write the above to the bus
000104 df8a                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000105 df7b                      	rcall stop_condition	// stop con
                                 
000106 e184                      	ldi DEL, 20
000107 dfbf                      	rcall delay
                                 
000108 9508                      	ret
                                 
                                 
                                 /* Read byte from eeprom
                                    Address located in Z
                                    Result stored on RBytr*/
                                 EEP_READ_BYTE:
                                 
000109 df6f                      	rcall start_condition	// start con
                                 
00010a ea40                      	ldi WOT, EEP_W			// EEP addr + write slave identifier into WOT
00010b df8e                      	rcall write_byte		// Write the above to the bus
00010c df82                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00010d e08a                      	ldi DEL, 10				// TAKE 5
00010e dfb8                      	rcall delay
                                 
00010f 2f4f                      	mov WOT, EEH			// value of EEH (memory high byte) into WOT
000110 df89                      	rcall write_byte		// Write the above to the bus
000111 df7d                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000112 2f4e                      	mov WOT, EEL			// value of EEL (memory low byte) into WOT
000113 df86                      	rcall write_byte		// Write the above to the bus
000114 df7a                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000115 df63                      	rcall start_condition	// repeated start con
                                 
000116 ea41                      	ldi WOT, EEP_R			// EEP addr + read slave identifier into WOT
000117 df82                      	rcall write_byte		// Write the above to the bus
000118 df76                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000119 e085                      	ldi DEL, 5				// TAKE 5
00011a dfac                      	rcall delay
                                  
00011b df86                      	rcall read_byte			// read a byte into RBytr for use 
00011c df72                      	rcall read_bit			// Master Not Acknowledge 
                                 
00011d df63                      	rcall stop_condition	// stop con
                                 
00011e 9508                      	ret
                                 
                                 /* Write byte to eeprom
                                    Address located in Z
                                    Data locate in DAT	*/
                                 EEP_WRITE_BYTE:
                                 
00011f df59                      	rcall start_condition	// start con
                                 
000120 ea40                      	ldi WOT, EEP_W			// EEP addr + write slave identifier into WOT
000121 df78                      	rcall write_byte		// Write the above to the bus
000122 df6c                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000123 e08a                      	ldi DEL, 10				// TAKE 5
000124 dfa2                      	rcall delay
                                 
000125 2f4f                      	mov WOT, EEH			// value of EEH (memory high byte) into WOT
000126 df73                      	rcall write_byte		// Write the above to the bus
000127 df67                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000128 2f4e                      	mov WOT, EEL			// value of EEL (memory low byte) into WOT
000129 df70                      	rcall write_byte		// Write the above to the bus
00012a df64                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00012b 2f46                      	mov WOT, DAT			// value of DAT into WOT
00012c df6d                      	rcall write_byte		// Write the above to the bus
00012d df61                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00012e df52                      	rcall stop_condition	// stop con
                                 
00012f 9508                      	ret
                                 
                                 PCF_READ_TIME:
                                 
000130 e0b0                      	ldi r27, 0x00			// set sram pointer to ramstart
000131 e4a0                      	ldi r26, 0x40
                                 	
000132 df46                      	rcall start_condition	// start con
                                 
000133 ea42                      	ldi WOT, PCF_W			// PCF addr + write slave identifier into WOT
000134 df65                      	rcall write_byte		// Write the above to the bus
000135 df59                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000136 e08a                      	ldi DEL, 10				// TAKE 5
000137 df8f                      	rcall delay
                                 
000138 e042                      	ldi WOT, VL_seconds		// set address pointer to VL_seconds
000139 df60                      	rcall write_byte		// Write the above to the bus
00013a df54                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00013b df3d                      	rcall start_condition	// start con
                                 
00013c ea43                      	ldi WOT, PCF_R			// PCF addr + write slave identifier into WOT
00013d df5c                      	rcall write_byte		// Write the above to the bus
00013e df50                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00013f e085                      	ldi DEL, 5				// TAKE 5
000140 df86                      	rcall delay
                                 
                                 
000141 e017                      	ldi LOP, 7				// set the loop to 7 variables
                                  
                                 	pcf_l_b:
                                 
000142 df5f                      	rcall read_byte			// read a byte into RBytr for use 
000143 df4b                      	rcall read_bit			// Master Not Acknowledge 
                                 
000144 933d                      	ST X+, RBytr			// store each successive in sram
000145 951a                      	DEC LOP					// lop--;
                                 
000146 3010                      	cpi LOP, 0				// if its 0 move on
000147 f7d1                      	brne pcf_l_b
                                 
000148 df38                      	rcall stop_condition	// stop con
                                 
000149 9508                      	ret
                                 
                                 
                                 
                                 load_prescaler: // reduces prescaler by 1 each time the sub is run by "blink faster" 
                                 
00014a 95a8                      	wdr
                                 
00014b 2700                      	clr GPR
00014c bf01                      	out WDTCSR, GPR			// clean up the wtachdog registers
                                 
00014d b701                      	in GPR, WDTCSR			// load the clean one
                                 
00014e 2f7c                      	mov GPRB, WPS			// do the requisite maths an=d bit setting
00014f 7077                      	andi GPRB, 0B0111
000150 2b07                      	or GPR, GPRB
                                 
000151 2f7c                      	mov GPRB, WPS
000152 0f77                      	lsl GPRB
000153 0f77                      	lsl GPRB
000154 7270                      	andi GPRB, 0B00100000
000155 2b07                      	or GPR, GPRB
                                 
000156 bf01                      	out WDTCSR, GPR
                                 
000157 b701                      	in GPR, WDTCSR
000158 6400                      	ori GPR, (1<<WDIE)
000159 7f07                      	andi GPR, ~(1<<WDE)
00015a bf01                      	out WDTCSR, GPR			// loads watchdog register
                                 
00015b 9508                      	ret
                                 
                                 blink_faster:	// decrements the prescaler and reloads the watchdog
                                 
00015c 95ca                      	dec WPS
00015d fdc7                      	sbrc WPS,7
00015e e0c9                      	ldi WPS, 0x09
                                 
00015f 2f6c                      	mov DAT, WPS
000160 dfe9                      	rcall load_prescaler
                                 
000161 9508                      	ret
                                 
                                 accel_event:	// runs whenever the accelerometer is knocked, saves data to memory
                                 	
000162 dff9                      	rcall blink_faster		// up the prescaler 
                                 
000163 2fed                      	mov EEL, EEC
000164 95d3                      	inc EEC
000165 e568                      	ldi DAT, 0x58
000166 dfb8                      	rcall EEP_WRITE_BYTE
                                 
000167 ef8f                      	ldi DEL, 255
000168 df5e                      	rcall delay
                                 
000169 2fed                      	mov EEL, EEC
00016a 95d3                      	inc EEC
00016b e568                      	ldi DAT, 0x58
00016c dfb2                      	rcall EEP_WRITE_BYTE
                                 
00016d ef8f                      	ldi DEL, 255
00016e df58                      	rcall delay
                                 
00016f 2fed                      	mov EEL, EEC
000170 95d3                      	inc EEC
000171 e568                      	ldi DAT, 0x58
000172 dfac                      	rcall EEP_WRITE_BYTE
                                 
000173 ef8f                      	ldi DEL, 255
000174 df52                      	rcall delay
                                 
000175 2fed                      	mov EEL, EEC
000176 95d3                      	inc EEC
000177 e568                      	ldi DAT, 0x58
000178 dfa6                      	rcall EEP_WRITE_BYTE
                                 
000179 ef8f                      	ldi DEL, 255
00017a df4c                      	rcall delay
                                 
00017b 2fed                      	mov EEL, EEC
00017c 95d3                      	inc EEC
00017d e568                      	ldi DAT, 0x58
00017e dfa0                      	rcall EEP_WRITE_BYTE
                                 
00017f ef8f                      	ldi DEL, 255
000180 df46                      	rcall delay
                                 
000181 2fed                      	mov EEL, EEC
000182 95d3                      	inc EEC
000183 e568                      	ldi DAT, 0x58
000184 df9a                      	rcall EEP_WRITE_BYTE
                                 
000185 ef8f                      	ldi DEL, 255
000186 df40                      	rcall delay
                                 
000187 2fed                      	mov EEL, EEC
000188 95d3                      	inc EEC
000189 e06a                      	ldi DAT, 0x0a
00018a df94                      	rcall EEP_WRITE_BYTE
                                 
00018b 9508                      	ret
                                 
                                 button_event:	// runs whenever the button is pressed, dumps data over uart
                                 
00018c ef8f                      	ldi DEL, 255			// set wait 
                                 
                                 	wait:					// wait until the button is released
00018d ded4                      	rcall read_SCL
00018e 3021                      	cpi RBitr, (1<<SCL)
00018f f7e9                      	brne wait
                                 
000190 df36                      	rcall delay				// wait a bunch
                                 
000191 e0c9                      	ldi WPS, 0x09
000192 2f6c                      	mov DAT, WPS
000193 dfb6                      	rcall load_prescaler	// clear the prescaler
                                 
000194 e010                      	ldi LOP, 0x00			// clear loop var and memory locations
000195 e0f0                      	ldi EEH, 0x00		
000196 e0e0                      	ldi EEL, 0x00
                                 
                                 	// loop through every memory address and send contents over uart
                                 	BYL_s:
000197 9513                      	inc LOP
000198 95e3                      	inc EEL
                                 
000199 df6f                      	rcall EEP_READ_BYTE
00019a 2f63                      	mov DAT, RBytr
00019b df10                      	rcall uart_byte
                                 
00019c 3f1f                      	cpi LOP, 255
00019d f7c9                      	brne BYL_s
                                 
00019e 9508                      	ret
                                 
                                 	
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny10" register use summary:
x  :   1 y  :   0 z  :   0 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  62 r17:  15 r18:  12 r19:   4 r20:  24 
r21:   8 r22:  19 r23:  12 r24:  23 r25:   2 r26:   1 r27:   1 r28:   9 
r29:  17 r30:  12 r31:   4 
Registers used: 17 out of 35 (48.6%)

"ATtiny10" instruction use summary:
.lds.l:   0 .sts.l:   0 adc   :   0 add   :   0 and   :   0 andi  :  15 
asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   0 
brcs  :   0 breq  :   0 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 brne  :   9 brpl  :   0 
brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   0 cbi   :   0 cbr   :   0 clc   :   0 clh   :   0 cli   :   3 
cln   :   0 clr   :   5 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   0 cp    :   0 cpc   :   0 cpi   :   9 cpse  :   0 dec   :   8 
eor   :   0 icall :   0 ijmp  :   0 in    :  18 inc   :  10 ld    :   0 
ldd   :   0 ldi   :  66 lds   :   0 lsl   :   4 lsr   :   1 mov   :  24 
neg   :   0 nop   :  40 or    :   3 ori   :   6 out   :  20 pop   :   0 
push  :   0 rcall : 120 ret   :  28 reti  :   2 rjmp  :   4 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 
sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   0 seh   :   0 sei   :   3 
sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 
sleep :   1 st    :   1 std   :   0 sts   :   0 sub   :   0 subi  :   0 
swap  :   0 tst   :   0 wdr   :   1 
Instructions used: 26 out of 99 (26.3%)

"ATtiny10" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00033e    818      0    818    1024  79.9%
[.dseg] 0x000040 0x000060      0      0      0      32   0.0%
[.eseg] 0x000000 0x000000      0      0      0       0      -

Assembly complete, 0 errors, 4 warnings

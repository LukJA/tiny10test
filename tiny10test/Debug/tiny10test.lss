
AVRASM ver. 2.2.6  C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm Sun Mar 26 18:33:51 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.1.102\avrasm\inc\tn10def.inc'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(67): warning: Register r28 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(69): warning: Register r31 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(70): warning: Register r30 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(72): warning: Register r29 already defined by the .DEF directive
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(162): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\deadData.asm'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(230): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\i2clib.asm'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(232): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\uartlib.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.1.102\avrasm\inc\tn10def.inc'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(162): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\deadData.asm'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(230): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\i2clib.asm'
C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\main.asm(232): Including file 'C:\Users\lukej\Documents\Atmel Studio\7.0\tiny10test\tiny10test\uartlib.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny10.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn10def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny10
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny10
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN10DEF_INC_
                                 #define _TN10DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny10
                                 #pragma AVRPART ADMIN PART_NAME ATtiny10
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x03
                                 
                                 #pragma AVRPART CORE CORE_VERSION AVR8L_0
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	CCP	= 0x3c
                                 .equ	RSTFLR	= 0x3b
                                 .equ	SMCR	= 0x3a
                                 .equ	OSCCAL	= 0x39
                                 .equ	CLKMSR	= 0x37
                                 .equ	CLKPSR	= 0x36
                                 .equ	PRR	= 0x35
                                 .equ	VLMCSR	= 0x34
                                 .equ	NVMCMD	= 0x33
                                 .equ	NVMCSR	= 0x32
                                 .equ	WDTCSR	= 0x31
                                 .equ	GTCCR	= 0x2f
                                 .equ	TCCR0A	= 0x2e
                                 .equ	TCCR0B	= 0x2d
                                 .equ	TCCR0C	= 0x2c
                                 .equ	TIMSK0	= 0x2b
                                 .equ	TIFR0	= 0x2a
                                 .equ	TCNT0L	= 0x28
                                 .equ	TCNT0H	= 0x29
                                 .equ	OCR0AL	= 0x26
                                 .equ	OCR0AH	= 0x27
                                 .equ	OCR0BL	= 0x24
                                 .equ	OCR0BH	= 0x25
                                 .equ	ICR0L	= 0x22
                                 .equ	ICR0H	= 0x23
                                 .equ	ACSR	= 0x1f
                                 .equ	ADCSRA	= 0x1d
                                 .equ	ADCSRB	= 0x1c
                                 .equ	ADMUX	= 0x1b
                                 .equ	ADCL	= 0x19
                                 .equ	DIDR0	= 0x17
                                 .equ	EICRA	= 0x15
                                 .equ	EIFR	= 0x14
                                 .equ	EIMSK	= 0x13
                                 .equ	PCICR	= 0x12
                                 .equ	PCIFR	= 0x11
                                 .equ	PCMSK	= 0x10
                                 .equ	PORTCR	= 0x0c
                                 .equ	PUEB	= 0x03
                                 .equ	PORTB	= 0x02
                                 .equ	DDRB	= 0x01
                                 .equ	PINB	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel Selection Bits
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 
                                 ; ADCL - ADC Data Register
                                 .equ	ADC0	= 0	; ADC Data Register Bit 0
                                 .equ	ADC1	= 1	; ADC Data Register Bit 1
                                 .equ	ADC2	= 2	; ADC Data Register Bit 2
                                 .equ	ADC3	= 3	; ADC Data Register Bit 3
                                 .equ	ADC4	= 4	; ADC Data Register Bit 4
                                 .equ	ADC5	= 5	; ADC Data Register Bit 5
                                 .equ	ADC6	= 6	; ADC Data Register Bit 6
                                 .equ	ADC7	= 7	; ADC Data Register Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture  Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; CCP - Configuration Change Protection
                                 .equ	CCP0	= 0	; Configuration Change Protection bit 0
                                 .equ	CCP1	= 1	; Configuration Change Protection bit 1
                                 .equ	CCP2	= 2	; Configuration Change Protection bit 2
                                 .equ	CCP3	= 3	; Configuration Change Protection bit 3
                                 .equ	CCP4	= 4	; Configuration Change Protection bit 4
                                 .equ	CCP5	= 5	; Configuration Change Protection bit 5
                                 .equ	CCP6	= 6	; Configuration Change Protection bit 6
                                 .equ	CCP7	= 7	; Configuration Change Protection bit 7
                                 
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; CLKMSR - Clock Main Settings Register
                                 .equ	CLKMS0	= 0	; Clock Main Select Bit 0
                                 .equ	CLKMS1	= 1	; Clock Main Select Bit 1
                                 
                                 ; CLKPSR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRTIM0	= 0	; Power Reduction Timer/Counter0
                                 .equ	PRADC	= 1	; Power Reduction ADC
                                 
                                 ; VLMCSR - Vcc Level Monitoring Control and Status Register
                                 .equ	VLM0	= 0	; Trigger Level of Voltage Level Monitor bit 0
                                 .equ	VLM1	= 1	; Trigger Level of Voltage Level Monitor bit 1
                                 .equ	VLM2	= 2	; Trigger Level of Voltage Level Monitor bit 2
                                 .equ	VLMIE	= 6	; VLM Interrupt Enable
                                 .equ	VLMF	= 7	; VLM Flag
                                 
                                 ; RSTFLR - Reset Flag Register
                                 .equ	PORF	= 0	; Power-on Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; NVMCSR - Non-Volatile Memory Control and Status Register
                                 .equ	NVMBSY	= 7	; Non-Volatile Memory Busy
                                 
                                 ; NVMCMD - Non-Volatile Memory Command
                                 .equ	NVMCMD0	= 0	; 
                                 .equ	NVMCMD1	= 1	; 
                                 .equ	NVMCMD2	= 2	; 
                                 .equ	NVMCMD3	= 3	; 
                                 .equ	NVMCMD4	= 4	; 
                                 .equ	NVMCMD5	= 5	; 
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTCR - Port Control Register
                                 .equ	BBMB	= 1	; Break-Before-Make Mode Enable
                                 
                                 ; PUEB - Pull-up Enable Control Register
                                 .equ	PUEB0	= 0	; 
                                 .equ	PUEB1	= 1	; 
                                 .equ	PUEB2	= 2	; 
                                 .equ	PUEB3	= 3	; 
                                 
                                 ; PORTB - Input Pins, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 
                                 ; PINB - Port B Data register
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 
                                 ; EIFR - External Interrupt Flag register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Mask Register
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0A - Timer/Counter 0 Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode for Channel B bit 0
                                 .equ	COM0B1	= 5	; Compare Output Mode for Channel B bit 1
                                 .equ	COM0A0	= 6	; Compare Output Mode for Channel A bit 0
                                 .equ	COM0A1	= 7	; Compare Output Mode for Channel A bit 1
                                 
                                 ; TCCR0B - Timer/Counter 0 Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; Waveform Generation Mode
                                 .equ	WGM03	= 4	; Waveform Generation Mode
                                 .equ	ICES0	= 6	; Input Capture Edge Select
                                 .equ	ICNC0	= 7	; Input Capture Noise Canceler
                                 
                                 ; TCCR0C - Timer/Counter 0 Control Register C
                                 .equ	FOC0B	= 6	; Force Output Compare for Channel B
                                 .equ	FOC0A	= 7	; Force Output Compare for Channel A
                                 
                                 ; TIMSK0 - Timer Interrupt Mask Register 0
                                 .equ	TOIE0	= 0	; Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Output Compare A Match Interrupt Enable
                                 .equ	OCIE0B	= 2	; Output Compare B Match Interrupt Enable
                                 .equ	ICIE0	= 5	; Input Capture Interrupt Enable
                                 
                                 ; TIFR0 - Overflow Interrupt Enable
                                 .equ	TOV0	= 0	; Timer Overflow Flag
                                 .equ	OCF0A	= 1	; Timer Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer Output Compare Flag 0B
                                 .equ	ICF0	= 5	; Input Capture Flag
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSR	= 0	; Prescaler Reset
                                 .equ	TSM	= 7	; Timer Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control and Status Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timer Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timer Interrupt Flag
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; BYTE0 fuse bits
                                 .equ	RSTDISBL	= 0	; Disable external reset
                                 .equ	WDTON	= 1	; Watch dog timer always on
                                 .equ	CKOUT	= 2	; Output external clock
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0040
                                 .equ	SRAM_SIZE	= 32
                                 .equ	RAMEND	= 0x005f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x0000
                                 .equ	EEPROMEND	= 0x0000
                                 
                                 ; ***** MEMORY MAPPED NVM ************************************************
                                 .equ	MAPPED_FLASH_START	= 0x4000
                                 .equ	MAPPED_LOCKBITS_0	= 0x3f00
                                 .equ	MAPPED_CONFIG_0	= 0x3f40
                                 .equ	MAPPED_CALIB_0	= 0x3f80
                                 .equ	MAPPED_SIGN_0	= 0x3fc0
                                 .equ	MAPPED_SIGN_1	= 0x3fc1
                                 .equ	MAPPED_SIGN_2	= 0x3fc2
                                 .equ	MAPPED_FLASH_SIZE	= 0x0400
                                 .equ	MAPPED_FLASH_END	= 0x43ff
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 0
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 32
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x40
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
                                 .equ	ICP0addr	= 0x0003	; Timer/Counter0 Input Capture
                                 .equ	OVF0addr	= 0x0004	; Timer/Counter0 Overflow
                                 .equ	OC0Aaddr	= 0x0005	; Timer/Counter Compare Match A
                                 .equ	OC0Baddr	= 0x0006	; Timer/Counter Compare Match B
                                 .equ	ACIaddr	= 0x0007	; Analog Comparator
                                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                                 .equ	VLMaddr	= 0x0009	; Vcc Voltage Level Monitor
                                 .equ	ADCCaddr	= 0x000a	; ADC Conversion Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 11	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _TN10DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; tiny10test.asm
                                 ;
                                 ; Created: 22/11/2016 21:30:59
                                 ; Author : lukej
                                 ;
                                 
                                 //--------------------------------------------- defines 
                                 
                                 .equ SDA = PB2 // define pins
                                 .equ SCL = PB0
                                 
                                 // LIS register addresses
                                 .equ LIS_W = 0B00110000 // lis addr + write
                                 .equ LIS_R = 0B00110001 // lis addr + read
                                 
                                 .equ CTRL_REG1 = 0x20
                                 .equ CTRL_REG2 = 0x21
                                 .equ CTRL_REG3 = 0x22
                                 .equ CTRL_REG4 = 0x23
                                 .equ CTRL_REG5 = 0x24
                                 .equ CTRL_REG6 = 0x25
                                 
                                 .equ INT1_CFG  = 0x30
                                 .equ INT1_SRC  = 0x31
                                 .equ INT1_THS  = 0x32
                                 .equ INT1_DURATION = 0x33
                                 
                                 // EEPROM address registers
                                 .equ EEP_W = 0B10100000 // eeprom addr + write
                                 .equ EEP_R = 0B10100001 // eeprom addr + read
                                 
                                 // PCF address registers
                                 .equ PCF_W = 0B10100010 // pcf + write
                                 .equ PCF_R = 0B10100011 // pcf + read
                                 
                                 .equ CTRL_STAT_1 = 0x00
                                 .equ CTRL_STAT_2 = 0x01
                                 .equ VL_seconds	= 0x02
                                 .equ Minutes	= 0x03
                                 .equ Hours		= 0x04
                                 .equ Days		= 0x05
                                 .equ Weekdays	= 0x06
                                 .equ Century_months	= 0x07
                                 .equ Years		= 0x08
                                 .equ CLKOUT_control	= 0x0D
                                 .equ Timer_control	= 0x0E
                                 .equ Timer		= 0x0F
                                 
                                 // internal 
                                 .def GPR = r16 // General purpose Reg (local) (assume nothing)
                                 .def GPRB = r23 // General purpose Reg B (local) (assume nothing)
                                 .def LOP = r17 // Register for loops
                                 
                                 .def RBitr = r18 // bit read reg
                                 .def RBytr = r19 // byte read reg
                                 
                                 .def WOT = r20 // write flow reg
                                 .def SAD = r21 // Sub address storage
                                 .def DAT = r22 // data storage
                                 
                                 .def DEL = r24 // delay reg
                                 .def DELH = r25 // delay higher reg
                                 
                                 // 26,27 used for pointing to sram
                                 
                                 .def WPS = r28 // watchdog prescaler
                                 
                                 .def EEH = r31  // we will be using the Z reg for addressing the EEprom
                                 .def EEL = r30  // Low bit too
                                 
                                 .def EEC = r29	// current address holder
                                 
                                 //--------------------------------------------
                                 
000000 c008                      rjmp skip				// making room for the interupt vector tables
                                 
                                 .org PCI0addr			// INT0addr is the address of EXT_INT0
000002 c089                      rjmp PCI0_vect			// so run the handler
                                 .org WDTaddr			// WDTaddr is the address of the WDT timeout
000008 c08e                      rjmp WDT_vect			// so run the handler
                                 
                                 skip:
                                 
                                 // CODE TO RUN: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                 
                                 // Setup the LIS3DH --
                                 
                                 // enable all axes, normal mode 100Hz rate
000009 e250                      ldi SAD, CTRL_REG1
00000a ea67                      ldi DAT, 0xA7
00000b d14e                      rcall LIS_CMD
                                 
                                 // disable the HP filter
                                 //ldi SAD, CTRL_REG2
                                 //ldi DAT, 0x00
                                 //rcall LIS_CMD
                                 
                                 // Int driven to INT1 pin
00000c e252                      ldi SAD, CTRL_REG3
00000d e460                      ldi DAT, 0x40
00000e d14b                      rcall LIS_CMD
                                 
                                 // Full Scale = 16G
00000f e253                      ldi SAD, CTRL_REG4
000010 e360                      ldi DAT, 0x30
000011 d148                      rcall LIS_CMD
                                 
                                 // Interupt latched 
                                 // commenting out will remove latching effect
                                 //ldi SAD, CTRL_REG5
                                 //ldi DAT, 0x08
                                 //rcall LIS_CMD
                                 
                                 // threshold absolute 
000012 e352                      ldi SAD, INT1_THS
000013 e76f                      ldi DAT, 0x7F
000014 d145                      rcall LIS_CMD
                                 
                                 // Set minimum duration to x <- this is effectively sensitivity
000015 e353                      ldi SAD, INT1_DURATION
000016 e069                      ldi DAT, 0x09
000017 d142                      rcall LIS_CMD
                                 
                                 // interrupt generation on all axis
000018 e350                      ldi SAD, INT1_CFG
000019 e06a                      ldi DAT, 0x0A
00001a d13f                      rcall LIS_CMD
                                 
                                 // ---------------
                                 
                                 
00001b e0f0                      ldi EEH, 0x00		// set location 0
00001c e0e0                      ldi EEL, 0x00		// set location 0
                                 
00001d e0d0                      ldi EEC, 0x00
                                 
00001e 95d3                      inc EEC		// increment location
                                 
                                 
                                 // ---------------
                                 
                                 // set up all interupts
00001f 94f8                      cli
                                 
                                 // enable wdt to blink slowly   
000020 e0c6                      ldi WPS, 0B0110		// highest timeout 
000021 2700                      clr GPR
000022 bf01                      out WDTCSR, GPR			// clean up
000023 d185                      rcall load_prescaler
                                 
                                 // enable pin change int on SCL for button, PB1 for LIS
                                 
000024 2700                      clr GPR
000025 e003                      ldi GPR, 0B0011
000026 bb00                      out PCMSK, GPR
000027 e001                      ldi GPR, 0B0001
000028 bb02                      out PCICR, GPR
                                 
                                 
                                 // ----------------------
                                 #include "deadData.asm"
                                 
000029 e0e1                      ldi EEL, 0x01
                                 
00002a e361                      ldi DAT, 0x31
00002b d152                      rcall EEP_WRITE_BYTE
                                 
00002c ef8f                      ldi DEL, 255
00002d e09a                      ldi DELH, 10
00002e d0fd                      rcall delayL
                                 
00002f 95e3                      inc EEL
000030 e362                      ldi DAT, 0x32
000031 d14c                      rcall EEP_WRITE_BYTE
                                 
000032 ef8f                      ldi DEL, 255
000033 e09a                      ldi DELH, 10
000034 d0f7                      rcall delayL
                                 
000035 95e3                      inc EEL
000036 e36a                      ldi DAT, 0x3A
000037 d146                      rcall EEP_WRITE_BYTE
                                 
000038 ef8f                      ldi DEL, 255
000039 e09a                      ldi DELH, 10
00003a d0f1                      rcall delayL
                                 
00003b 95e3                      inc EEL
00003c e363                      ldi DAT, 0x33
00003d d140                      rcall EEP_WRITE_BYTE
                                 
00003e ef8f                      ldi DEL, 255
00003f e09a                      ldi DELH, 10
000040 d0eb                      rcall delayL
                                 
000041 95e3                      inc EEL
000042 e365                      ldi DAT, 0x35
000043 d13a                      rcall EEP_WRITE_BYTE
                                 
000044 ef8f                      ldi DEL, 255
000045 e09a                      ldi DELH, 10
000046 d0e5                      rcall delayL
                                 
000047 95e3                      inc EEL
000048 e260                      ldi DAT, 0x20
000049 d134                      rcall EEP_WRITE_BYTE
                                 
00004a ef8f                      ldi DEL, 255
00004b e09a                      ldi DELH, 10
00004c d0df                      rcall delayL
                                 
00004d 95e3                      inc EEL
00004e e366                      ldi DAT, 0x36
00004f d12e                      rcall EEP_WRITE_BYTE
                                 
000050 ef8f                      ldi DEL, 255
000051 e09a                      ldi DELH, 10
000052 d0d9                      rcall delayL
                                 
000053 95e3                      inc EEL
000054 e26f                      ldi DAT, 0x2f
000055 d128                      rcall EEP_WRITE_BYTE
                                 
000056 ef8f                      ldi DEL, 255
000057 e09a                      ldi DELH, 10
000058 d0d3                      rcall delayL
                                 
000059 95e3                      inc EEL
00005a e367                      ldi DAT, 0x37
00005b d122                      rcall EEP_WRITE_BYTE
                                 
00005c ef8f                      ldi DEL, 255
00005d e09a                      ldi DELH, 10
00005e d0cd                      rcall delayL
                                 
00005f 95e3                      inc EEL
000060 e26f                      ldi DAT, 0x2f
000061 d11c                      rcall EEP_WRITE_BYTE
                                 
000062 ef8f                      ldi DEL, 255
000063 e09a                      ldi DELH, 10
000064 d0c7                      rcall delayL
                                 
000065 95e3                      inc EEL
000066 e361                      ldi DAT, 0x31
000067 d116                      rcall EEP_WRITE_BYTE
                                 
000068 ef8f                      ldi DEL, 255
000069 e09a                      ldi DELH, 10
00006a d0c1                      rcall delayL
                                 
00006b 95e3                      inc EEL
00006c e366                      ldi DAT, 0x36
00006d d110                      rcall EEP_WRITE_BYTE
                                 
00006e ef8f                      ldi DEL, 255
00006f e09a                      ldi DELH, 10
000070 d0bb                      rcall delayL
                                 
000071 95e3                      inc EEL
000072 e260                      ldi DAT, 0x20
000073 d10a                      rcall EEP_WRITE_BYTE
                                 
000074 ef8f                      ldi DEL, 255
000075 e09a                      ldi DELH, 10
000076 d0b5                      rcall delayL
                                 
000077 95e3                      inc EEL
000078 e46c                      ldi DAT, 0x4C
000079 d104                      rcall EEP_WRITE_BYTE
                                 
00007a ef8f                      ldi DEL, 255
00007b e09a                      ldi DELH, 10
00007c d0af                      rcall delayL
                                 
00007d 95e3                      inc EEL
00007e e366                      ldi DAT, 0x36
00007f d0fe                      rcall EEP_WRITE_BYTE
                                 
000080 ef8f                      ldi DEL, 255
000081 e09a                      ldi DELH, 10
000082 d0a9                      rcall delayL
                                 
000083 95e3                      inc EEL
000084 e460                      ldi DAT, 0x40
000085 d0f8                      rcall EEP_WRITE_BYTE
000086 e0e0                      
000087 9478                      sei
                                 start:				// main loop
                                 
000088 e005                      ldi GPR, 0B0101		// Sleep code
000089 bf0a                      out SMCR, GPR		// set sleep mode to power down + enable
00008a 9588                      sleep
                                 
00008b cffc                      rjmp start
                                 
                                 // ----------------------
                                 
                                 // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                 
                                 
                                 
                                 
                                 // Interrupt vectors
                                 
                                 // LIS threshhold exceeded interupt OR button pressed interupt
                                 PCI0_vect:
                                 
00008c 94f8                      	cli
                                 	
00008d d032                      	rcall read_SCL	// read the pin to check if it was the button
                                 
00008e ff20                      	sbrs RBitr, SCL	// if it was run button
00008f d15b                      	rcall button_event // button
                                 
000090 d035                      	rcall read_PB1 // read to see if it was the accelerometer
                                 
000091 ff21                      	sbrs RBitr, PB1 // if it was run accel
000092 d12e                      	rcall accel_event
                                 
000093 ef8f                      	ldi DEL, 255				// TAKE 5
000094 d091                      	rcall delay
                                 
000095 9478                      	sei
                                 
000096 9518                      	reti // esc
                                 
                                 // Periodic watchdog interupt
                                 WDT_vect:
                                 
000097 94f8                      	cli
                                 
000098 d00b                      	rcall low_SDA // pulse led 
                                 
000099 b701                      	in GPR, WDTCSR		// clear the watchdog
00009a 6400                      	ori GPR, (1<<WDIE)
00009b 6008                      	ori GPR, (1<<WDE)
00009c bf01                      	out WDTCSR, GPR
                                 
00009d ef8f                      	ldi DEL, 255 // delay		
00009e d087                      	rcall delay
                                 
00009f ef8f                      	ldi DEL, 255 // delay			 
0000a0 d085                      	rcall delay
                                 
0000a1 d009                      	rcall high_SDA // pulse led
                                 	
0000a2 9478                      	sei
                                 
0000a3 9518                      	reti
                                 
                                 
                                 // include i2c external library
                                 #include "i2clib.asm"
                                 
                                 
                                 // I2C Low Level
                                 
                                 /* Pull the SDA line low */
                                 low_SDA:				// SDA -> GND
                                 
0000a4 b101                      	in  GPR, DDRB		// read DDR 
0000a5 6004                      	ori  GPR, (1<<SDA)  // add SDA set bit
0000a6 b901                      	out DDRB, GPR		// set sda output
                                 
0000a7 b102                      	in  GPR, PORTB		// read portb 
0000a8 7f0b                      	andi GPR, ~(1<<SDA) // mask SDA bit
0000a9 b902                      	out PORTB, GPR		// set output low
                                 
0000aa 9508                      	ret
                                 	
                                 /* Allow the SDA line to tristate (ext Pull-Up) */
                                 high_SDA:				// SDA -> tristate
                                 
0000ab b101                      	in  GPR, DDRB		// read DDR 
0000ac 7f0b                      	andi GPR, ~(1<<SDA) // mask SDA bit
0000ad b901                      	out DDRB, GPR		// set sda input
                                 
0000ae 9508                      	ret
                                 	
                                 /* Pull the SCL line low */
                                 low_SCL:				// SCL -> GND
                                 
0000af b101                      	in  GPR, DDRB		// read DDR 
0000b0 6001                      	ori  GPR, (1<<SCL)  // add SCL set bit
0000b1 b901                      	out DDRB, GPR		// set scl output
                                 
0000b2 b102                      	in  GPR, PORTB		// read portb 
0000b3 7f0e                      	andi GPR, ~(1<<SCL) // mask SCL bit
0000b4 b902                      	out PORTB, GPR		// set output low
                                 
0000b5 9508                      	ret
                                 	
                                 /* Allow the SDA line to tristate (ext Pull-Up) */
                                 high_SCL:				// SCL -> tristate
                                 
0000b6 b101                      	in  GPR, DDRB		// read DDR 
0000b7 7f0e                      	andi GPR, ~(1<<SCL) // mask SCL bit
0000b8 b901                      	out DDRB, GPR		// set scl input
                                 
0000b9 9508                      	ret
                                 
                                 /* read the current level of SDA into the RBitr reg masking to SDA only */
                                 read_SDA:
                                 	
0000ba b101                      	in  GPR, DDRB		// read DDR 
0000bb 7f0b                      	andi GPR, ~(1<<SDA) // mask SDA bit
0000bc b901                      	out DDRB, GPR		// set sda input
                                 
0000bd b120                      	in  RBitr, PINB		// read pinB into RBitr
0000be 7024                      	andi RBitr, (1<<SDA)// mask to SDA
                                 
0000bf 9508                      	ret
                                 	
                                 /* read the current level of SCL into the RBitr reg masking to SCL only */
                                 read_SCL:
                                 	
0000c0 b101                      	in  GPR, DDRB		// read DDR 
0000c1 7f0e                      	andi GPR, ~(1<<SCL) // mask SCL bit
0000c2 b901                      	out DDRB, GPR		// set scl input
                                 
0000c3 b120                      	in  RBitr, PINB		// read pinB into RBitr
0000c4 7021                      	andi RBitr, (1<<SCL)// mask to SDA
                                 
0000c5 9508                      	ret
                                 
                                 /* read the current level of PB1 into the RBitr reg masking to PB1 only */
                                 read_PB1:
                                 	
0000c6 b101                      	in  GPR, DDRB		// read DDR 
0000c7 7f0d                      	andi GPR, ~(1<<PB1) // mask SCL bit
0000c8 b901                      	out DDRB, GPR		// set scl input
                                 
0000c9 b120                      	in  RBitr, PINB		// read pinB into RBitr
0000ca 7022                      	andi RBitr, (1<<PB1)// mask to SDA
                                 
0000cb 9508                      	ret
                                 
                                 	/* Pull the SDA line low */
                                 low_PB1:				// SDA -> GND
                                 
0000cc b101                      	in  GPR, DDRB		// read DDR 
0000cd 6002                      	ori  GPR, (1<<PB1)  // add SDA set bit
0000ce b901                      	out DDRB, GPR		// set sda output
                                 
0000cf b102                      	in  GPR, PORTB		// read portb 
0000d0 7f0d                      	andi GPR, ~(1<<PB1) // mask SDA bit
0000d1 b902                      	out PORTB, GPR		// set output low
                                 
0000d2 9508                      	ret
                                 	
                                 /* Allow the SDA line to tristate (ext Pull-Up) */
                                 high_PB1:				// SDA -> tristate
                                 
0000d3 b101                      	in  GPR, DDRB		// read DDR 
0000d4 7f0d                      	andi GPR, ~(1<<PB1) // mask SDA bit
0000d5 b901                      	out DDRB, GPR		// set sda input
                                 
0000d6 9508                      	ret
                                 
                                 
                                 // I2C High Level
                                 
                                 /* Perform a start condition or restart condition, performs both */
                                 start_condition:
                                 
0000d7 dfd3                      	rcall high_SDA		// SDA high <- allows for restart to use same call
0000d8 dfdd                      	rcall high_SCL		// SCL high 
                                 	
0000d9 0000                      	nop					// take a real quick break (no op)
                                 	
0000da dfc9                      	rcall low_SDA		// SDA low BEFORE
0000db 0000                      	nop					// break
0000dc dfd2                      	rcall low_SCL		// SCL low NEXT
0000dd 0000                      	nop					// break
                                 	
0000de 9508                      	ret
                                 
                                 /* perform a stop condition */
                                 stop_condition:
                                 
0000df dfc4                      	rcall low_SDA		// just make sure
0000e0 0000                      	nop					// break
0000e1 dfd4                      	rcall high_SCL		// SCL high BEFORE
0000e2 0000                      	nop					// break
0000e3 dfc7                      	rcall high_SDA		// SDA high NEXT
                                 
0000e4 9508                      	ret
                                 
                                 /* write the MSB of the WOT to the SDA pin and pulse the clock */
                                 write_bit:	
                                 
0000e5 fd47                      	sbrc WOT, 7			// skip the next line if WOT[7] = 0
0000e6 dfc4                      		rcall high_SDA
0000e7 ff47                      	sbrs WOT, 7			// skip the next line if WOT[7] = 1
0000e8 dfbb                      		rcall low_SDA
                                 			
0000e9 dfcc                      	rcall high_SCL		// pulse clock
0000ea 0000                      	nop
0000eb dfc3                      	rcall low_SCL
                                 
0000ec 9508                      	ret
                                 	
                                 /* read the current level of SDA and insert it into RBitr[0]
                                    seperated from RBytr so that this can be used for ack/nack */
                                 read_bit:
                                 
0000ed 0000                      	nop
0000ee dfc7                      	rcall high_SCL		// clock up to lock data
0000ef 0000                      	nop
                                 
0000f0 dfc9                      	rcall read_SDA		// read SDA into RBitr
                                 
0000f1 2700                      	clr GPR			
0000f2 fd22                      	sbrc RBitr, SDA		// skip the next line if SDA bit in RBitr is cleared
0000f3 e001                      	ldi  GPR, 0x1		
0000f4 2f20                      	mov RBitr, GPR		// set the LSB of RBitr to be the value of SDA
                                 
0000f5 0000                      	nop
0000f6 dfb8                      	rcall low_SCL		// clock down to accept new data
                                 
0000f7 9508                      	ret
                                 
                                 /* write the contents of WOT the I2C line */
                                 write_byte:
                                 
0000f8 e018                      	ldi LOP, 8		// init loop reg
                                 
                                 	w_b_s:
0000f9 951a                      	dec LOP			// loop--
                                 
0000fa dfea                      	rcall write_bit // write the MSB to the bus
0000fb 0f44                      	lsl WOT			// left shift to the next bit to send
                                 
0000fc 3010                      	cpi LOP, 0		// check if its 0 yet
0000fd f7d9                      	brne w_b_s		// if not go back to w_b_s
                                 
0000fe dfac                      	rcall high_SDA	// release control of SDA
0000ff 9508                      	ret
                                 
                                 /* read a byte of data from the bus via read_bit, and store the result in RBytr */
                                 read_byte:
                                 
000100 e018                      	ldi LOP, 8		// init loop reg
                                 
000101 2777                      	clr GPRB		// clean GPRB for use (GPR is used in read_bit)
                                 
                                 	r_b_s:
000102 951a                      	dec LOP			// loop--
                                 
000103 dfe9                      	rcall read_bit	// read a bit into RBitr
000104 0f77                      	lsl GPRB		// shift the GP to the left to free the next spot
000105 2b72                      	or GPRB, RBitr	// move the read bit into said spot
                                 
000106 3010                      	cpi LOP, 0		// check if its 0 yet
000107 f7d1                      	brne r_b_s		// if not go back to r_b_s
                                 
000108 2f37                      	mov RBytr, GPRB // move the new read byte into its designated reg
000109 9508                      	ret
                                 
                                 // include uart external library
                                 #include "uartlib.asm"
                                 
                                    Use DAT
                                    Finely tuned to 19200 baud 
                                    8 data 1 stop
                                    lsb first */
                                 // Uart output a byte
                                 uart_byte:
                                 
00010a 2f46                      	mov WOT, DAT			// value of DAT into WOT
00010b e018                      	ldi LOP, 8				// init loop reg
                                 
00010c dfbf                      	rcall low_PB1			// start condition is initially low
                                 
00010d e084                      	ldi DEL, 4				// tuning delay
00010e d017                      	rcall delay
00010f 0000                      	nop						// tuning delay
000110 0000                      	nop
                                 
                                 	u_a_s:
000111 951a                      	dec LOP					// loop-- plays the data out over the bus one bit at a time
                                 
000112 fd40                      	sbrc WOT, 0				// skip the next line if WOT[0] = 0
000113 dfbf                      		rcall high_PB1
000114 ff40                      	sbrs WOT, 0				// skip the next line if WOT[0] = 1
000115 dfb6                      		rcall low_PB1
000116 9546                      	lsr WOT					// left shift to the next bit to send
                                 		
000117 e083                      	ldi DEL, 3				// tuning delay
000118 d00d                      	rcall delay
                                 
000119 0000                      	nop						// tuning delay
00011a 0000                      	nop
00011b 0000                      	nop
                                 
00011c 3010                      	cpi LOP, 0				// check if its 0 yet
00011d f799                      	brne u_a_s				// if not go back to u_a_s
                                 
00011e 0000                      	nop						// tuning delay
00011f 0000                      	nop
000120 0000                      	nop
000121 0000                      	nop
                                 
000122 dfb0                      	rcall high_PB1			// release control of SDA
000123 9508                      	ret
                                 
                                 // uart input a byte
                                 
                                 uart_recieve:
                                 	
000124 0000                      	nop 
                                 
000125 9508                      
                                 
                                 // User routines
                                 
                                 /* just something to delay by twice the number in DEL */
                                 delay:
                                 	d_s:
000126 958a                      	dec DEL
000127 0000                      	nop
000128 0000                      	nop
000129 3080                      	cpi DEL, 0
00012a f7d9                      	brne d_s
                                 
00012b 9508                      	ret
                                 
                                 delayL:
                                 	dLH_s:
00012c 959a                      	dec DELH
                                 	dL_s:
00012d 958a                      	dec DEL
00012e 0000                      	nop
00012f 0000                      	nop
000130 0000                      	nop
000131 0000                      	nop
000132 0000                      	nop
000133 0000                      	nop
000134 0000                      	nop
000135 0000                      	nop
000136 0000                      	nop
000137 0000                      	nop
000138 0000                      	nop
000139 0000                      	nop
00013a 0000                      	nop
00013b 0000                      	nop
00013c 0000                      	nop
00013d 0000                      	nop
00013e 0000                      	nop
00013f 0000                      	nop
000140 0000                      	nop
000141 0000                      	nop
000142 3080                      	cpi DEL, 0
000143 f749                      	brne dL_s
000144 3090                      	cpi DELH, 0
000145 f731                      	brne dLH_s
                                 
000146 9508                      	ret
                                 
                                 /* Read command for LIS3DH 
                                    reads sub-address SAD into RBytr */
                                 LIS_READ:
                                 
000147 df8f                      	rcall start_condition	// start con
                                 
000148 e340                      	ldi WOT, LIS_W			// lis addr + write slave identifier into WOT
000149 dfae                      	rcall write_byte		// Write the above to the bus
00014a dfa2                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00014b e08a                      	ldi DEL, 10				// TAKE 5
00014c dfd9                      	rcall delay
                                 
00014d 2f45                      	mov WOT, SAD			// value of SAD (sub address in lis reg file) into WOT
00014e dfa9                      	rcall write_byte		// Write the above to the bus
00014f df9d                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000150 df86                      	rcall start_condition	// repeated start con
                                 
000151 e341                      	ldi WOT, LIS_R			// lis addr + read slave identifier into WOT
000152 dfa5                      	rcall write_byte		// Write the above to the bus
000153 df99                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000154 e085                      	ldi DEL, 5				// TAKE 5
000155 dfd0                      	rcall delay
                                  
000156 dfa9                      	rcall read_byte			// read a byte into RBytr for use 
000157 df95                      	rcall read_bit			// Master Not Acknowledge 
                                 
000158 df86                      	rcall stop_condition	// stop con
                                 
000159 9508                      	ret
                                 
                                 /* Write command for LIS3DH 
                                    writes DAT into sub-address SAD */
                                 LIS_CMD:	 
                                 
00015a df7c                      	rcall start_condition	// start con
                                 
00015b e340                      	ldi WOT, LIS_W			// lis addr + write slave identifier into WOT
00015c df9b                      	rcall write_byte		// Write the above to the bus
00015d df8f                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00015e 2f45                      	mov WOT, SAD			// value of SAD (sub address in lis reg file) into WOT
00015f df98                      	rcall write_byte		// Write the above to the bus
000160 df8c                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000161 2f46                      	mov WOT, DAT			// value of DAT into WOT
000162 df95                      	rcall write_byte		// Write the above to the bus
000163 df89                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000164 df7a                      	rcall stop_condition	// stop con
                                 
000165 e184                      	ldi DEL, 20
000166 dfbf                      	rcall delay
                                 
000167 9508                      	ret
                                 
                                 
                                 /* Read byte from eeprom
                                    Address located in Z
                                    Result stored on RBytr*/
                                 EEP_READ_BYTE:
                                 
000168 df6e                      	rcall start_condition	// start con
                                 
000169 ea40                      	ldi WOT, EEP_W			// EEP addr + write slave identifier into WOT
00016a df8d                      	rcall write_byte		// Write the above to the bus
00016b df81                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00016c e08a                      	ldi DEL, 10				// TAKE 5
00016d dfb8                      	rcall delay
                                 
00016e 2f4f                      	mov WOT, EEH			// value of EEH (memory high byte) into WOT
00016f df88                      	rcall write_byte		// Write the above to the bus
000170 df7c                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000171 2f4e                      	mov WOT, EEL			// value of EEL (memory low byte) into WOT
000172 df85                      	rcall write_byte		// Write the above to the bus
000173 df79                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000174 df62                      	rcall start_condition	// repeated start con
                                 
000175 ea41                      	ldi WOT, EEP_R			// EEP addr + read slave identifier into WOT
000176 df81                      	rcall write_byte		// Write the above to the bus
000177 df75                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000178 e085                      	ldi DEL, 5				// TAKE 5
000179 dfac                      	rcall delay
                                  
00017a df85                      	rcall read_byte			// read a byte into RBytr for use 
00017b df71                      	rcall read_bit			// Master Not Acknowledge 
                                 
00017c df62                      	rcall stop_condition	// stop con
                                 
00017d 9508                      	ret
                                 
                                 /* Write byte to eeprom
                                    Address located in Z
                                    Data locate in DAT	*/
                                 EEP_WRITE_BYTE:
                                 
00017e df58                      	rcall start_condition	// start con
                                 
00017f ea40                      	ldi WOT, EEP_W			// EEP addr + write slave identifier into WOT
000180 df77                      	rcall write_byte		// Write the above to the bus
000181 df6b                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000182 e08a                      	ldi DEL, 10				// TAKE 5
000183 dfa2                      	rcall delay
                                 
000184 2f4f                      	mov WOT, EEH			// value of EEH (memory high byte) into WOT
000185 df72                      	rcall write_byte		// Write the above to the bus
000186 df66                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000187 2f4e                      	mov WOT, EEL			// value of EEL (memory low byte) into WOT
000188 df6f                      	rcall write_byte		// Write the above to the bus
000189 df63                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00018a 2f46                      	mov WOT, DAT			// value of DAT into WOT
00018b df6c                      	rcall write_byte		// Write the above to the bus
00018c df60                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00018d df51                      	rcall stop_condition	// stop con
                                 
00018e 9508                      	ret
                                 
                                 PCF_READ_TIME:
                                 
00018f e0b0                      	ldi r27, 0x00			// set sram pointer to ramstart
000190 e4a0                      	ldi r26, 0x40
                                 	
000191 df45                      	rcall start_condition	// start con
                                 
000192 ea42                      	ldi WOT, PCF_W			// PCF addr + write slave identifier into WOT
000193 df64                      	rcall write_byte		// Write the above to the bus
000194 df58                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
000195 e08a                      	ldi DEL, 10				// TAKE 5
000196 df8f                      	rcall delay
                                 
000197 e042                      	ldi WOT, VL_seconds		// set address pointer to VL_seconds
000198 df5f                      	rcall write_byte		// Write the above to the bus
000199 df53                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00019a df3c                      	rcall start_condition	// start con
                                 
00019b ea43                      	ldi WOT, PCF_R			// PCF addr + write slave identifier into WOT
00019c df5b                      	rcall write_byte		// Write the above to the bus
00019d df4f                      	rcall read_bit			// slave Acknowledge (no error checking yet)
                                 
00019e e085                      	ldi DEL, 5				// TAKE 5
00019f df86                      	rcall delay
                                 
                                 
0001a0 e017                      	ldi LOP, 7				// set the loop to 7 variables
                                  
                                 	pcf_l_b:
                                 
0001a1 df5e                      	rcall read_byte			// read a byte into RBytr for use 
0001a2 df4a                      	rcall read_bit			// Master Not Acknowledge 
                                 
0001a3 933d                      	ST X+, RBytr			// store each successive in sram
0001a4 951a                      	DEC LOP					// lop--;
                                 
0001a5 3010                      	cpi LOP, 0				// if its 0 move on
0001a6 f7d1                      	brne pcf_l_b
                                 
0001a7 df37                      	rcall stop_condition	// stop con
                                 
0001a8 9508                      	ret
                                 
                                 
                                 
                                 load_prescaler: // reduces prescaler by 1 each time the sub is run by "blink faster" 
                                 
0001a9 95a8                      	wdr
                                 
0001aa 2700                      	clr GPR
0001ab bf01                      	out WDTCSR, GPR			// clean up the wtachdog registers
                                 
0001ac b701                      	in GPR, WDTCSR			// load the clean one
                                 
0001ad 2f7c                      	mov GPRB, WPS			// do the requisite maths an=d bit setting
0001ae 7077                      	andi GPRB, 0B0111
0001af 2b07                      	or GPR, GPRB
                                 
0001b0 2f7c                      	mov GPRB, WPS
0001b1 0f77                      	lsl GPRB
0001b2 0f77                      	lsl GPRB
0001b3 7270                      	andi GPRB, 0B00100000
0001b4 2b07                      	or GPR, GPRB
                                 
0001b5 bf01                      	out WDTCSR, GPR
                                 
0001b6 b701                      	in GPR, WDTCSR
0001b7 6400                      	ori GPR, (1<<WDIE)
0001b8 7f07                      	andi GPR, ~(1<<WDE)
0001b9 bf01                      	out WDTCSR, GPR			// loads watchdog register
                                 
0001ba 9508                      	ret
                                 
                                 blink_faster:	// decrements the prescaler and reloads the watchdog
                                 
0001bb 95ca                      	dec WPS
0001bc fdc7                      	sbrc WPS,7
0001bd e0c9                      	ldi WPS, 0x09
                                 
0001be 2f6c                      	mov DAT, WPS
0001bf dfe9                      	rcall load_prescaler
                                 
0001c0 9508                      	ret
                                 
                                 accel_event:	// runs whenever the accelerometer is knocked, saves data to memory
                                 	
0001c1 dff9                      	rcall blink_faster		// up the prescaler 
                                 
0001c2 2fed                      	mov EEL, EEC
0001c3 95d3                      	inc EEC
0001c4 e468                      	ldi DAT, 0x48
0001c5 dfb8                      	rcall EEP_WRITE_BYTE
                                 
0001c6 ef8f                      	ldi DEL, 255
0001c7 df5e                      	rcall delay
                                 
0001c8 2fed                      	mov EEL, EEC
0001c9 95d3                      	inc EEC
0001ca e665                      	ldi DAT, 0x65
0001cb dfb2                      	rcall EEP_WRITE_BYTE
                                 
0001cc ef8f                      	ldi DEL, 255
0001cd df58                      	rcall delay
                                 
0001ce 2fed                      	mov EEL, EEC
0001cf 95d3                      	inc EEC
0001d0 e66c                      	ldi DAT, 0x6c
0001d1 dfac                      	rcall EEP_WRITE_BYTE
                                 
0001d2 ef8f                      	ldi DEL, 255
0001d3 df52                      	rcall delay
                                 
0001d4 2fed                      	mov EEL, EEC
0001d5 95d3                      	inc EEC
0001d6 e66c                      	ldi DAT, 0x6c
0001d7 dfa6                      	rcall EEP_WRITE_BYTE
                                 
0001d8 ef8f                      	ldi DEL, 255
0001d9 df4c                      	rcall delay
                                 
0001da 2fed                      	mov EEL, EEC
0001db 95d3                      	inc EEC
0001dc e66f                      	ldi DAT, 0x6f
0001dd dfa0                      	rcall EEP_WRITE_BYTE
                                 
0001de ef8f                      	ldi DEL, 255
0001df df46                      	rcall delay
                                 
0001e0 2fed                      	mov EEL, EEC
0001e1 95d3                      	inc EEC
0001e2 e261                      	ldi DAT, 0x21
0001e3 df9a                      	rcall EEP_WRITE_BYTE
                                 
0001e4 ef8f                      	ldi DEL, 255
0001e5 df40                      	rcall delay
                                 
0001e6 2fed                      	mov EEL, EEC
0001e7 95d3                      	inc EEC
0001e8 e460                      	ldi DAT, 0x40
0001e9 df94                      	rcall EEP_WRITE_BYTE
                                 
0001ea 9508                      	ret
                                 
                                 button_event:	// runs whenever the button is pressed, dumps data over uart
                                 
0001eb ef8f                      	ldi DEL, 255			// set wait 
                                 
                                 	wait:					// wait until the button is released
0001ec ded3                      	rcall read_SCL
0001ed 3021                      	cpi RBitr, (1<<SCL)
0001ee f7e9                      	brne wait
                                 
0001ef df36                      	rcall delay				// wait a bunch
                                 
0001f0 e0c9                      	ldi WPS, 0x09
0001f1 2f6c                      	mov DAT, WPS
0001f2 dfb6                      	rcall load_prescaler	// clear the prescaler
                                 
0001f3 e010                      	ldi LOP, 0x00			// clear loop var and memory locations
0001f4 e0f0                      	ldi EEH, 0x00		
0001f5 e0e0                      	ldi EEL, 0x00
                                 
                                 
                                 	// loop through every memory address and send contents over uart
                                 	BYL_s:
0001f6 9513                      	inc LOP
0001f7 95e3                      	inc EEL
                                 
0001f8 df6f                      	rcall EEP_READ_BYTE
                                 
0001f9 2f63                      	mov DAT, RBytr
0001fa df0f                      	rcall uart_byte
                                 
0001fb 3430                      	cpi RBytr, 0x40
0001fc f011                      	breq end 
                                 
0001fd 3f1f                      	cpi LOP, 255
0001fe f7b9                      	brne BYL_s
                                 	end:
                                 
0001ff 9508                      	ret
                                 
                                 	
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny10" register use summary:
x  :   1 y  :   0 z  :   0 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  62 r17:  15 r18:  12 r19:   4 r20:  24 
r21:   8 r22:  35 r23:  12 r24:  39 r25:  17 r26:   1 r27:   1 r28:   9 
r29:  16 r30:  29 r31:   4 
Registers used: 17 out of 35 (48.6%)

"ATtiny10" instruction use summary:
.lds.l:   0 .sts.l:   0 adc   :   0 add   :   0 and   :   0 andi  :  15 
asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   0 
brcs  :   0 breq  :   1 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 brne  :   9 brpl  :   0 
brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   0 cbi   :   0 cbr   :   0 clc   :   0 clh   :   0 cli   :   3 
cln   :   0 clr   :   5 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   0 cp    :   0 cpc   :   0 cpi   :  10 cpse  :   0 dec   :   8 
eor   :   0 icall :   0 ijmp  :   0 in    :  18 inc   :  25 ld    :   0 
ldd   :   0 ldi   : 115 lds   :   0 lsl   :   4 lsr   :   1 mov   :  23 
neg   :   0 nop   :  41 or    :   3 ori   :   6 out   :  20 pop   :   0 
push  :   0 rcall : 151 ret   :  28 reti  :   2 rjmp  :   4 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 
sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   0 seh   :   0 sei   :   3 
sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 
sleep :   1 st    :   1 std   :   0 sts   :   0 sub   :   0 subi  :   0 
swap  :   0 tst   :   0 wdr   :   1 
Instructions used: 27 out of 99 (27.3%)

"ATtiny10" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000400   1012      0   1012    1024  98.8%
[.dseg] 0x000040 0x000060      0      0      0      32   0.0%
[.eseg] 0x000000 0x000000      0      0      0       0      -

Assembly complete, 0 errors, 4 warnings
